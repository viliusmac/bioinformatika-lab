# -*- coding: utf-8 -*-
"""Bio_Informatika_1_lab.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18QG5F4pEFE40R9jfrdQNtdX4z0f3760r

Bioinformatikos lab.1 darbas 
Vilius Macijauskas - 1911074

Sekos turi būti sukeltos į Google drive:
/content/drive/MyDrive/bioinformatika1
"""

import itertools
!pip install biopython
from Bio.Seq import Seq
from Bio import SeqIO
from google.colab import drive
drive.mount('/content/drive/')

START_CODONS = ['ATG']
END_CODONS = ['TAG', 'TAA', 'TGA']
LETTERS = ['A','T','C','G']

def generateDicodons(list):
  dicodons = []
  for firstC in list:
    for secondC in list:
      dicodons.append(firstC + secondC)
  return dicodons

ALL_CODONS = [''.join(comb) for comb in itertools.product(LETTERS, repeat=3)]
ALL_DICODONS = generateDicodons(ALL_CODONS)

# Šis metodas nebuvo panaudotas sekų ieškojime, nes paprastesnis variantas buvo tai padaryti einant per sekas pirmą kartą (pagal atsakymą iš MS Teams)
# Palieku, kad užpildytų pirmą punktą
def findCodonPositions(sequence):
  start_codons = {'frame0': [], 'frame1': [], 'frame2': []}
  end_codons = {'frame0': [], 'frame1': [], 'frame2': []}

  seq_pos = 0
  current_frame = 0
  while seq_pos < len(sequence) - 2:

    if sequence[seq_pos] + sequence[seq_pos + 1] + sequence[seq_pos + 2] in START_CODONS:
      start_codons.get('frame' + str(current_frame)).append(seq_pos)

    if sequence[seq_pos] + sequence[seq_pos + 1] + sequence[seq_pos + 2] in END_CODONS:
      end_codons.get('frame' + str(current_frame)).append(seq_pos)

    current_frame = (current_frame + 1) % 3
    seq_pos += 1

  return start_codons, end_codons

def findPossibleCombinations(sequence):
  combinations = {'frame0': [], 'frame1': [], 'frame2': []}

  seq_pos = 0
  current_frame = 0
  start_pos = [None,None,None]
  while seq_pos < len(sequence) - 2:

    if sequence[seq_pos] + sequence[seq_pos + 1] + sequence[seq_pos + 2] in START_CODONS:
      if start_pos[current_frame] == None:
        start_pos[current_frame] = seq_pos

    if sequence[seq_pos] + sequence[seq_pos + 1] + sequence[seq_pos + 2] in END_CODONS:
      if start_pos[current_frame] != None:
        combinations.get('frame' + str(current_frame)).append({'start': start_pos[current_frame], 'end': seq_pos})
        start_pos[current_frame] = None

    current_frame = (current_frame + 1) % 3
    seq_pos += 1

  return combinations

def filterLongPairs(combinations, min_length):
  filtered_combinations = {'frame0': [], 'frame1': [], 'frame2': []}

  for frame in range(0, 3):
    for combo in combinations.get('frame' + str(frame)):
      if combo.get('end') - combo.get('start') + 3 > min_length:
        filtered_combinations.get('frame' + str(frame)).append(combo)

  return filtered_combinations

def extractSequences(sequence, combinations):
  sequences = []

  for frame in range(0, 3):
    for combo in combinations.get('frame' + str(frame)):
      sequences.append(sequence[combo.get('start') + 3:combo.get('end')])

  return sequences

def findCodonsFrequency(sequences):
  frequencies = {}
  codonCount = 0
  i = 0

  for codon in ALL_CODONS:
      frequencies[codon] = 0

  for clipping in sequences:
    while i < len(clipping) - 2:
      codon = clipping[i:i + 3]
      frequencies[codon] += 1
      codonCount += 1
      i += 1

  for codon in ALL_CODONS:
      frequencies[codon] = round(frequencies[codon] / codonCount, 3)

  return frequencies

def findDicodonsFrequency(sequences):
  frequencies = {}
  dicodonCount = 0
  i = 0

  for dicodon in ALL_DICODONS:
    frequencies[dicodon] = 0

  for clipping in sequences:
    while i < len(clipping) - 5:
      dicodon = clipping[i:i + 6]
      frequencies[dicodon] += 1
      dicodonCount += 1
      i += 1

  for dicodon in ALL_DICODONS:
      frequencies[dicodon] = round(frequencies[dicodon] / dicodonCount, 3)

  return frequencies

def compareFrequencies(frequencies1, frequencies2, codons):
  distance = 0
  for codon in codons:
    distance += abs(frequencies1[codon] - frequencies2[codon])
  return distance

def computeFrequencies(sequence):
  reverse_sequence = str(Seq(sequence).reverse_complement())
  sequence = str(sequence)

  # surandame sekų pradžias ir pabaigas skirtinguose frame'uose, kurių pradžios yra toliausiai nuo pabaigų
  combinations = findPossibleCombinations(sequence);
  rev_combinations = findPossibleCombinations(reverse_sequence);

  # atfiltruojame per trumpas sekas
  combinations = filterLongPairs(combinations, 100)
  rev_combinations = filterLongPairs(rev_combinations, 100)

  # iš sekos sudaromos iškarpos
  sequences = extractSequences(sequence, combinations)
  rev_sequences = extractSequences(sequence, rev_combinations)

  # randami kodonų dažniai 
  codon_frequencies = findCodonsFrequency(sequences + rev_sequences)

  # randami dikodonų dažniai 
  dicodon_frequencies = findDicodonsFrequency(sequences + rev_sequences)

  return {'codon_frequencies': codon_frequencies, 'dicodon_frequencies': dicodon_frequencies}

# Buvo naudojamas surikiuoti kodonų/dikodonų sąrašus pagal dydžius ataskaitai
def findMostCommonStrings(frequencies, all_strings):
  sorted_list = []
  for x in all_strings:
    sorted_list.append((x, frequencies.get(x)))
  return sorted(sorted_list, key = lambda x: x[1], reverse = True)

data = [{'filename':'bacterial1.fasta','virus':'Lactococcus_phage'},
        {'filename':'bacterial2.fasta','virus':'KM389305.1'},
        {'filename':'bacterial3.fasta','virus':'NC_028697.1'},
        {'filename':'bacterial4.fasta','virus':'KC821626.1'},
        {'filename':'mamalian1.fasta','virus':'coronavirus'},
        {'filename':'mamalian2.fasta','virus':'adenovirus'},
        {'filename':'mamalian3.fasta','virus':'U18337.1'},
        {'filename':'mamalian4.fasta','virus':'herpesvirus'}]
        
frequencies = {}

for data_element in data:
  sequence = SeqIO.read("/content/drive/MyDrive/bioinformatika1/" + data_element['filename'], "fasta")
  frequencies[data_element['virus']] = computeFrequencies(sequence.seq)

for x in data:
  print(x['virus'],end = " ")
  for y in data:
    print(round(compareFrequencies(frequencies[x['virus']]['codon_frequencies'],frequencies[y['virus']]['codon_frequencies'], ALL_CODONS),3),end = " ")
  print()

for x in data:
  print(x['virus'],end = " ")
  for y in data:
    print(round(compareFrequencies(frequencies[x['virus']]['dicodon_frequencies'],frequencies[y['virus']]['dicodon_frequencies'], ALL_DICODONS),3),end = " ")
  print()